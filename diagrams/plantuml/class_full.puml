@startuml
note as n
  <b>Note</b>: To save space, constructor parameter types,
  which match the types of the class parameters,
  are not specified
end note

class Audio {
        +NDArray[float] array
        +int sampling_frequency
    }

package view {
    abstract class AView<<Observer>> {
        #Callable[[Audio], None] sound_player
        #Dict[EExperimentState, Optional[str]] experiment_texts

        +AView(sound_player, experiment_texts)

        #void {abstract} update_new_stimulus(stimulus: CreatedStimulus)
        #void {abstract} updated_new_primer(primer: str)
        #void {abstract} update_experiment_state_changed(data: EExperimentState)
        +void update(data: Any, identifier: EModelUpdateIdentifier
        +bool {abstract} get_confirmation()
        +void {abstract} wait(secs: int)
    }

    class PsychopyView {
    }

    class CLIView {
    }
}

package model {
    abstract class AObserver {
        +void update(data: Any, identifier: EModelUpdateIdentifier)
    }

    class Model <<Observable>>{
        -List[str] primer_history

        -Model(raw_stimuli: List[Stimulus], auditory_stimulus_factories: List[AAudioTaggerFactory])
        -void notify(data: Any, identifier: EModelUpdateIdentifier)
        +void register(view: AObserver)
        +void new_stimulus(stimulus: CreatedStimulus)
        +void new_primer(stimulus: CreatedStimulus)
        +void change_experiment_state(new_state: EExperimentState)
    }

    class Logger<<Observer>> {
        -Path exports_directory
        +Logger(logging_directory: PathLike)
    }
    Logger -u-|> AObserver

    package constants {
    enum EExperimentState {
        INACTIVE
        INTRODUCTION
        RESTING_STATE_EYES_OPEN
        RESTING_STATE_EYES_CLOSED
        EXPERIMENT_INTRODUCTION
        EXPERIMENT
    }

    enum EModelUpdateIdentifier {
        NEW_STIMULUS
        NEW_PRIMER
        EXPERIMENT_STATE_CHANGED
    }
    }

    class Stimulus {
        +str prompt
        +str primer
        +List[str] options
        +List[Tuple[float, float]] time_stamps
        +int target
    }
    Stimulus "1" *-- "1" Audio: audio

    class CreatedStimulus {
        -Stimulus stimulus
        +Optional[str] used_tagger_label

        +CreatedStimulus(stimulus: Stimulus, modified_audio: Audio)
        +str prompt()
        +str primer()
        +List[str] options()
        +List[Tuple[float, float]] time_stamps()
        +int target()
    }
    CreatedStimulus "1" *-l- "1" Audio: modified_audio


    CreatedStimulus "*" *-- "1" Stimulus
}

Model "1" *-r- "*" CreatedStimulus: "stimulus_history"
Model "*" o--- "1" EExperimentState: "experiment_state"
Model "1" o-l-- "*" AObserver
Model ..> EModelUpdateIdentifier: "uses"

AObserver .l.> constants: "uses"

AView --|> AObserver


package auditory_tagging {
    abstract class AAudioTagger {
      #list[ [float, float] ] stimuli_intervals

      +AAuditoryTagger(audio, stimuli)
      +Audio {abstract} create()
    }

    AAudioTagger "1" *-- "1" Audio: audio


    abstract class AAudioTaggerFactory {
      +AAudioTagger {abstract} create_audio_tagger(audio: Audio, stimuli_intervals: List[Tuple[float, float])
    }

    package assr_tagger {
        class AMTagger {
          -int frequency
          -Callable[[int, int, int], NDArray[float] tag_generator
          -[float, float] signal_interval

          +ASSRTagger(audio, stimuli_intervals, frequency, tag_generator, signal_interval)
          +Audio create()
        }

        class FMTagger {
          -int frequency
          -float modulation_factor

          +FMTagger(audio, stimuli_intervals, frequency, modulation_factor)
          +Audio create()
          -(NDArray[Real], NDArray[Real]) {static} extract_amplitudes_phases(numbers: NDArray[Complex])
          -NDArray[Complex] {static} get_complex_number(amplitudes: NDArray[Real], phases: NDArray[Real])
          -NDArray[Real] phases_to_instantaneous_frequencies(phases: NDArray[Real])
          -NDArray[Real] instantaneous_frequencies_to_phases(instantaneous_frequencies: NDArray[Real], first_phase: Real)
          -NDArray[float32] modulate(signal: NDArray[float32])

        }

        class FlippedFMTagger {
          -int frequency

          +FlippedFMTagger(audio, stimuli_intervals, frequency)
          +Audio create()

        }

        class AMTaggerFactory {
          -int frequency
          -Callable[[int, int, int], NDArray[float]] tag_generator
          -(float, float) signal_interval

          +AMTaggerFactory(frequency, tag_generator, signal_interval)
        }

        class FlippedFMTaggerFactory {
          -int frequency

          +FlippedFMTaggerFactory(frequency)
        }

        class FMTaggerFactory {
          -int frequency

          +FMTaggerFactory(frequency)
        }
    }

    class NoiseTaggingTagger {
      -Optional[int] seed
      -int bit_width
      -int length_bit
      +Optional[Code] code

      +NoiseTaggingTagger(audio, stimuli_intervals, bits_per_second: int, length_bit, seed)
      +Audio create()
      -void __generate_code()
      -void __get_code(length: int)
    }

    class NoiseTaggingTaggerFactory {
      -int bits_per_second
      -int length_bit
      -Optional[int] seed

      +NoiseTaggingTaggerFactory(bits_per_second, length_bit, seed)
    }

    class RawTagger {
      +Audio create()
    }

    class RawTaggerFactory {
    }

    package shift_taggers {
        class ShiftSumTagger {
          -int shift_by

          +ShiftSumTagger(audio, stimuli_intervals, shift_by)
          +Audio create()
        }

        class ShiftSumTaggerFactory {
          -int shift_by
          +ShiftSumTaggerFactory(shift_by)
        }

        class SpectrumShiftTagger {
          -int shift_by

          +SpectrumShiftTagger(audio, stimuli_intervals, shift_by)
          +Audio create()
        }

        class SpectrumShiftTaggerFactory {
          -int shift_by
          +SpectrumShiftTaggerFactory(shift_by)
        }
    }
}


package eeg {
   enum ETrigger{
     +ETrigger {static} get_trigger(data: Any, identifier: EModelUpdateIdentifier
   }
   note right of ETrigger: Contains tha mappings to\nthe actual trigger numbers\nsent

    abstract class TriggerSender {
        #void {abstract} send_trigger(trigger: ETrigger)
    }

   class BittiumTriggerSender<<Observer>> {
     -IParallelPort parallel_port
     -int trigger_duration_s
     +BittiumTriggerSender(parallel_port, trigger_duration_s)
     #void send_trigger(trigger: ETrigger)
   }
}
TriggerSender -u-|> AObserver
BittiumTriggerSender -r-|> TriggerSender
BittiumTriggerSender ..> ETrigger: "uses"


AAudioTagger <|-- SpectrumShiftTagger
AAudioTagger <|-- ShiftSumTagger
AAudioTagger <|-- RawTagger
AAudioTagger <|-- NoiseTaggingTagger
AAudioTagger <|-- AMTagger
AAudioTagger <|-- FMTagger
AAudioTagger <|-- FlippedFMTagger

AAudioTaggerFactory <|-u- SpectrumShiftTaggerFactory
AAudioTaggerFactory <|-u- ShiftSumTaggerFactory
AAudioTaggerFactory <|-u- AMTaggerFactory
AAudioTaggerFactory <|-u- FMTaggerFactory
AAudioTaggerFactory <|-u- FlippedFMTaggerFactory
AAudioTaggerFactory <|-u- NoiseTaggingTaggerFactory
AAudioTaggerFactory <|-u- RawTaggerFactory

SpectrumShiftTagger <.. SpectrumShiftTaggerFactory: "creates"
ShiftSumTagger <.. ShiftSumTaggerFactory: "creates"
AMTagger <.. AMTaggerFactory: "creates"
FMTagger <.. FMTaggerFactory: "creates"
FlippedFMTagger <.. FlippedFMTaggerFactory: "creates"
NoiseTaggingTagger <.. NoiseTaggingTaggerFactory: "creates"
RawTagger <.. RawTaggerFactory: "creates"

AView <|-- PsychopyView
AView <|-- CLIView



class Experiment {
    +Experiment(model: Model, view: AView, stimuli: List[Stimulus], auditory_stimulus_factories: List[AAudioTaggerFactory])
    +void create_stimuli()
    +void run()
}
Experiment "1" *-- "1" Model
Experiment "1" *-- "1" AView

Model "1" *-u- "*" AAudioTaggerFactory
Model "1" *-- "*" Stimulus: raw_stimuli
Model "1" *-- "*" CreatedStimulus: created_stimuli
note on link: Created by calling  `create_stimuli()`

Experiment -[hidden] auditory_tagging
@enduml
