@startuml
note as n
  <b>Note</b>: To save space, constructor parameter types,
  which match the types of the class parameters,
  are not specified
end note

class Audio {
        +NDArray[float] array
        +int sampling_frequency
    }

package view {
    abstract class AView<<Observer>> {
        #Callable[[Audio], None] sound_player
        #Dict[EExperimentState, Optional[str]] experiment_texts

        +AView(sound_player, experiment_texts)

        #void {abstract} update_new_stimulus(stimulus: CreatedStimulus)
        #void {abstract} updated_new_primer(primer: str)
        #void {abstract} update_experiment_state_changed(data: EExperimentState)
        +void update(data: Any, identifier: EModelUpdateIdentifier
        +bool {abstract} get_confirmation()
        +void {abstract} wait(secs: int)
    }

    class PsychopyView {
    }

    class CLIView {
    }
}

package model {
    abstract class AObserver {
        +void update(data: Any, identifier: EModelUpdateIdentifier)
    }

    class Model <<Observable>>{
        -List[str] primer_history

        -Model()
        -void notify(data: Any, identifier: EModelUpdateIdentifier)
        +void register(view: AObserver)
        +void new_stimulus(stimulus: CreatedStimulus)
        +void new_primer(stimulus: CreatedStimulus)
        +void change_experiment_state(new_state: EExperimentState)
    }

    class Logger<<Observer>> {
        -Path exports_directory
        +Logger(logging_directory: PathLike)
    }
    Logger -u-|> AObserver

    package constants {
    enum EExperimentState {
        INACTIVE
        INTRODUCTION
        RESTING_STATE_EYES_OPEN
        RESTING_STATE_EYES_CLOSED
        EXPERIMENT_INTRODUCTION
        EXPERIMENT
    }

    enum EModelUpdateIdentifier {
        NEW_STIMULUS
        NEW_PRIMER
        EXPERIMENT_STATE_CHANGED
    }
    }

    class Stimulus {
        +str prompt
        +str primer
        +List[str] options
        +List[Tuple[float, float]] time_stamps
    }
    Stimulus "1" *-- "1" Audio: audio

    class CreatedStimulus {
        +Optional[str] used_tagger_label
        +CreatedStimulus {static} from_stimulus(stimulus: Stimulus, modified_audio: Audio)
    }
    CreatedStimulus "1" *-l- "1" Audio: modified_audio


    CreatedStimulus --|> Stimulus
}

Model "1" *-r- "*" CreatedStimulus: "stimulus_history"
Model "*" o--- "1" EExperimentState: "experiment_state"
Model "1" o-l-- "*" AObserver
Model ..> EModelUpdateIdentifier: "uses"

AObserver .l.> constants: "uses"

AView --|> AObserver


package auditory_tagging {
    abstract class AAuditoryTagger {
      #list[ [float, float] ] stimuli_intervals

      +AAuditoryTagger(audio, stimuli)
      +Audio {abstract} create()
    }

    AAuditoryTagger "1" *-- "1" Audio: audio


    abstract class AAudioTaggerFactory {
      +AAudioTagger {abstract} create_auditory_stimulus(audio: Audio, stimuli_intervals: List[Tuple[float, float])
    }

    package assr_tagger {
        class AMTagger {
          -int frequency
          -Callable[[int, int, int], NDArray[float] tag_generator

          +ASSRTagger(audio, stimuli_intervals, frequency, tag_generator)
          +Audio create()
        }

        class FMTagger {
          -int frequency

          +FMTagger(audio, stimuli_intervals, frequency)
          +Audio create()

        }

        class AMTaggerFactory {
          -int frequency
          -Callable[[int, int, int], NDArray[float]] tag_generator

          +AMTaggerFactory(frequency, tag_generator)
          +AAudioTagger create_auditory_stimulus(audio: Audio, stimuli_intervals: List[Tuple[float, float])
        }

        class FMTaggerFactory {
          -int frequency

          +FMTaggerFactory(frequency)
          +AAudioTagger create_auditory_stimulus(audio: Audio, stimuli_intervals: List[Tuple[float, float])
        }
    }

    class NoiseTaggingTagger {
      -Optional[int] seed
      -int bit_width
      -int length_bit
      +Optional[Code] code

      +NoiseTaggingTagger(audio, stimuli_intervals, bits_per_second: int, length_bit, seed)
      +Audio create()
      -void __generate_code()
      -void __get_code(length: int)
    }

    class NoiseTaggingTaggerFactory {
      -int bits_per_second
      -int length_bit
      -Optional[int] seed

      +NoiseTaggingTaggerFactory(bits_per_second, length_bit, seed)
      +AAudioTagger create_auditory_stimulus(audio: Audio, stimuli_intervals: List[Tuple[float, float])
    }

    class RawTagger {
      +Audio create()
    }

    class RawTaggerFactory {
      +AAudioTagger create_auditory_stimulus(audio: Audio, stimuli_intervals: List[Tuple[float, float])
    }
}

package eeg {
   enum ETrigger{}
   note right of ETrigger: Contains tha mappings to\nthe actual trigger numbers\nsent sent

   class BittiumTriggerSender<<Observer>> {
     -IParallelPort parallel_port
     -int trigger_duration_s
     +BittiumTriggerSender(address: int, trigger_duration_s)
   }
}
BittiumTriggerSender -u-|> AObserver
BittiumTriggerSender ..> ETrigger: "uses"


AAuditoryTagger <|-- RawTagger
AAuditoryTagger <|-- NoiseTaggingTagger
AAuditoryTagger <|-- AMTagger
AAuditoryTagger <|-- FMTagger

AAudioTaggerFactory <|-u- AMTaggerFactory
AAudioTaggerFactory <|-u- FMTaggerFactory
AAudioTaggerFactory <|-u- NoiseTaggingTaggerFactory
AAudioTaggerFactory <|-u- RawTaggerFactory

AMTagger <.. AMTaggerFactory: "creates"
FMTagger <.. FMTaggerFactory: "creates"
NoiseTaggingTagger <.. NoiseTaggingTaggerFactory: "creates"
RawTagger <.. RawTaggerFactory: "creates"

AView <|-- PsychopyView
AView <|-- CLIView



class Experiment {
    +Experiment(model: Model, view: AView, stimuli: List[Stimulus], auditory_stimulus_factories: List[AAudioTaggerFactory])
    +void create_stimuli()
    +void run()
}
Experiment "1" *-d- "1" Model
Experiment "1" *-l- "1" AView
Experiment "1" *-u- "*" AAudioTaggerFactory
Experiment "1" *-- "*" CreatedStimulus
note on link: Created by calling  `create_stimuli()`



@enduml
