from numbers import Number
from typing import List, Tuple, Callable

import numpy as np
import numpy.typing as npt

from auditory_stimulation.auditory_stimulus.auditory_stimulus import AAuditoryStimulus, Audio


def duplicate_signal(signal: npt.NDArray[Number]) -> npt.NDArray[Number]:
    """Given a one dimensional signal (N/Nx1) returns the signal duplicated to two dimensions (Nx2).

    :param signal: The to be duplicated signal.
    :return: The duplicated signal.
    """
    if len(signal.shape) > 1 or (len(signal.shape) == 2 and signal.shape[1] == 1):
        raise ValueError("The passed signal needs to be one dimensional!")

    output = np.array([np.copy(signal), np.copy(signal)]).T
    assert output.shape[1] == 2
    assert output.shape[0] == signal.shape[0]

    return output


def __common_stimulus_generation_tests(length: int, frequency: int, sampling_frequency: int):
    if length <= 0:
        raise ValueError("Length must be a positive integer!")

    if frequency <= 0:
        raise ValueError("Frequency must be a positive integer!")

    if sampling_frequency <= 0:
        raise ValueError("Sampling frequency must be a positive integer!")


def sine_signal(length: int, frequency: int, sampling_frequency: int) -> npt.NDArray[np.float32]:
    """Used to generate the modulating sine signal of the given length.

    :param length: The length in samples of the modulating ASSR signal.
    :param frequency: The frequency of the sine wave.
    :param sampling_frequency: The sampling frequency of the signal.
    :return: The modulating ASSR sine wave.
    """
    __common_stimulus_generation_tests(length, frequency, sampling_frequency)

    signal = np.sin(frequency / sampling_frequency * 2 * np.pi * np.arange(length))
    assert signal.shape[0] == length
    assert len(signal.shape) == 1

    return signal


def clicking_signal(length: int, frequency: int, sampling_frequency: int) -> npt.NDArray[np.float32]:
    """ Used to generate the modulating ASSR signal of the given length.

    :param length: The length in samples of the modulating ASSR signal.
    :param frequency: The frequency of the to be generated signal.
    :param sampling_frequency: The sampling frequency of the signal.
    :return: The modulating ASSR clicking signal.
    """
    __common_stimulus_generation_tests(length, frequency, sampling_frequency)

    # in order to be able to generate the altering signal properly, the 2 x frequency needs to divide the
    #  sampling rate of the original audio signal. if this is not the case, one of the saw-teeth will be longer
    #  than other, which may mess with the frequency
    if sampling_frequency // (frequency * 2) != sampling_frequency / (frequency * 2):
        raise ValueError("The frequency has to be fully divisible by the audio sampling frequency!")

    # set all values to 1 as default
    signal = np.ones(length)

    # set all necessary to -1
    first = sampling_frequency // (frequency * 2)
    step = sampling_frequency // frequency
    for i in range(first, length, step):
        # calculate modified interval end. If the interval end is out of range, set it to the range
        interval_end = i + step // 2
        if i + step // 2 > length:
            interval_end = length

        signal[i:interval_end] = -np.ones(interval_end - i)

    return signal


class ASSRStimulus(AAuditoryStimulus):
    """Creates an auditory ASSR stimulus. The ASSR stimulus is generated by multiplying the specified regions of the
    signal, with a sawtooth signal (between -1 and 1) of the appropriate frequency.
    """
    __frequency: int
    __stimulus_generation: Callable[[int, int, int], npt.NDArray[np.float32]]

    def __init__(self,
                 audio: Audio,
                 stimuli_intervals: List[Tuple[float, float]],
                 audio_player: Callable[[Audio], None],
                 frequency: int,
                 stimulus_generation: Callable[[int, int, int], npt.NDArray[np.float32]]) -> None:
        """Constructs the ASSRStimulus object

        :param audio: Object containing the audio signal as a numpy array and the sampling frequency of the audio
        :param stimuli_intervals: The intervals given in seconds, which will be modified with the stimulus. The
         intervals must be contained within the audio.
        :param audio_player: A function, which if given an audio plays it.
        :param frequency: The frequency of the ASSR stimulus
        """

        super().__init__(audio, stimuli_intervals, audio_player)

        if frequency <= 0:
            raise ValueError("The frequency has to be a positive number")

        self.__frequency = frequency
        self.__stimulus_generation = stimulus_generation

    def _create_modified_audio(self) -> Audio:
        """This method is implemented from the abstract super class. When called, it generates the ASSR stimulus
        modified audio.

        :return: The ASSR stimulus modified audio.
        """

        audio_copy = np.copy(self._audio.audio)

        for interval in self._stimuli_intervals:
            sample_range = (int(interval[0] * self._audio.sampling_frequency),
                            int(interval[1] * self._audio.sampling_frequency))

            # generate sine of the appropriate frequency
            added_signal = self.__stimulus_generation(sample_range[1] - sample_range[0],
                                                      self.__frequency, self._audio.sampling_frequency)

            duplicated_signal = duplicate_signal(added_signal)
            audio_copy[sample_range[0]:sample_range[1]] *= duplicated_signal

        # new_max = np.max([np.abs(np.min(audio_copy)), np.max(audio_copy)])
        # return Audio(audio_copy / new_max, self._audio.sampling_frequency)
        return Audio(audio_copy, self._audio.sampling_frequency)
