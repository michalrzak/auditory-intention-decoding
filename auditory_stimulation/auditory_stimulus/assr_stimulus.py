from typing import List, Tuple, Callable, Any

import numpy as np
import numpy.typing as npt

from auditory_stimulation.auditory_stimulus.auditory_stimulus import AAuditoryStimulus, Audio


class ASSRStimulus(AAuditoryStimulus):
    """Creates an auditory ASSR stimulus. The ASSR stimulus is generated by multiplying the specified regions of the
    signal, with a sawtooth signal (between -1 and 1) of the appropriate frequency.
    """
    __frequency: int

    def __init__(self, audio: Audio, stimuli_intervals: List[Tuple[float, float]],
                 audio_player: Callable[[Audio], None], frequency: int) -> None:
        super().__init__(audio, stimuli_intervals, audio_player)

        if frequency <= 0:
            raise ValueError("The frequency has to be a positive number")

        # in order to be able to generate the altering signal properly, the 2 x frequency needs to divide the
        #  sampling rate of the original audio signal. if this is not the case, one of the saw-teeth will be longer
        #  than other, which may mess with the frequency
        if audio.sampling_frequency // (frequency * 2) != \
                audio.sampling_frequency / (frequency * 2):
            raise ValueError("The frequency has to be fully divisible by the audio sampling frequency!")

        self.__frequency = frequency

    def __generate_added_signal(self, length: int) -> npt.NDArray[np.float32]:
        # TODO: add tests if this becomes the default
        # set all values to 1 as default
        signal = np.ones(length)

        # set all necessary to -1
        first = self._audio.sampling_frequency // (self.__frequency * 2)
        step = self._audio.sampling_frequency // self.__frequency
        for i in range(first, length, step):
            interval_end = i + step // 2 if i + step // 2 <= length else length
            signal[i:interval_end] = -np.ones(interval_end - i)

        return signal

    def __duplicate_to_audio_channels(self, signal: npt.NDArray[Any], audio: npt.NDArray[np.float32]):
        if len(signal.shape) != 1:
            raise ValueError("Signal has to have zero dimensions in the second dimension")

        if audio.shape[1] != 2:
            raise NotImplementedError("Sorry, but only audio of size Nx2 is supported at the moment")

        return np.array([np.copy(signal), np.copy(signal)]).T

    def _create_modified_audio(self) -> Audio:
        audio_copy = np.copy(self._audio.audio)

        for interval in self._stimuli_intervals:
            sample_range = (int(interval[0] * self._audio.sampling_frequency),
                            int(interval[1] * self._audio.sampling_frequency))

            # generate sine of the appropriate frequency
            added_signal = self.__generate_added_signal(sample_range[1] - sample_range[0])

            duplicated_signal = self.__duplicate_to_audio_channels(added_signal, self._audio.audio)
            audio_copy[sample_range[0]:sample_range[1]] *= duplicated_signal

        # new_max = np.max([np.abs(np.min(audio_copy)), np.max(audio_copy)])
        # return Audio(audio_copy / new_max, self._audio.sampling_frequency)
        return Audio(audio_copy, self._audio.sampling_frequency)
